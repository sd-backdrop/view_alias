<?php
/**
 * @file
 * Hook implementations for view alias module integration.
 *
 * @ingroup pathauto
 */

/**
 * Implements hook_pathauto().
 */
function view_alias_pathauto($op) {
  switch ($op) {
    case 'settings':

      $settings = array();
      $settings['module'] = 'view_alias';
      $settings['token_type'] = 'term'; //view_alias

      $settings['groupheader'] = t('View Alias Paths');
      $settings['patterndescr'] = t('Default View Alias pattern (applies to all views with a term argument and page display)');
      $settings['patterndefault'] = ''; // Not used

      $settings['batch_update_callback'] = 'view_alias_pathauto_bulkupdate';

      return (object) $settings;
      break;
  }
}

function view_alias_pattern_id($alias) {
  return 'pathauto_view_alias_' . $alias->bundle  . '_pattern';
}

function view_alias_alias_pattern($path) {
  return (strpos($path, '%') === FALSE) ?
    preg_replace('/\/?$/', '/[term:name]', $path) :
    str_replace(array('%/', '%'), '[term:name]/', $path);
}

/**
 * Batch processing callback; Generate aliases for taxonomy terms.
 */
function view_alias_pathauto_bulkupdate(&$context) {
  $aliasable = _get_aliasable_displays();
  foreach ($aliasable as $alias) {
    if (variable_get(view_alias_pattern_id($alias), FALSE)) {
      foreach ($alias->varg as $machine_name) {
        $voc = taxonomy_vocabulary_machine_name_load($machine_name);
        $terms = taxonomy_get_tree($voc->vid);
        foreach ($terms as $term) {
          view_alias_create_alias($term, $alias, 'bulkupdate');
        }
      }
    }
  }
}

/**
 * Implements hook_path_alias_types().
 * allows me to hook into the bulk delete
 */
function view_alias_path_alias_types() {
  $aliasable = _get_aliasable_displays();
  foreach ($aliasable as $alias) {
    $objects[$alias->path] = t('Views page displays having a path of @path', array('@path' => $alias->path));
  }
  return $objects;
}

/**
 * Implements hook_form_alter().
 * remove the default form settings and add our own since view alias are different from the regular aliases
 */
function view_alias_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'pathauto_patterns_form') {
    unset($form['view_alias']['token_help']);
    unset($form['view_alias']['pathauto_view_alias_pattern']);

    $form['view_alias']['views_to_alias'] = array(
      '#type' => 'fieldset',
      '#title' => 'Views available for aliasing',
      '#description' => 'Check the views for which aliases should be bulk generated.',
      '#weight' => -1,
    );

    $aliasable = _get_aliasable_displays();
    foreach ($aliasable as $alias) {
      $names = implode(', ', $alias->varg);
      $pattern_id = view_alias_pattern_id($alias);
      $pattern = view_alias_alias_pattern($alias->path);
      $form['view_alias']['views_to_alias'][$pattern_id] = array(
        '#type' => 'checkbox',
        '#title' => t('View <strong>@view_name</strong>, display <strong>@display_name</strong>, on path <strong>@path</strong>, with <strong>@name</strong> arguments.',
            array(
              '@view_name' => $alias->view_name,
              '@display_name' => $alias->display_name,
              '@path' => $alias->path,
              '@name' => $names,
            )
          ),
        '#weight' => -1,
        '#return_value' => $pattern,
        '#default_value' => (variable_get($pattern_id, FALSE) == $pattern),
      );
    }
  }
}

/**
 * Implements hook_taxonomy_term_insert().
 */
function view_alias_taxonomy_term_insert($term) {
  $aliasable = _get_aliasable_displays();
  foreach ($aliasable as $alias) {
    if (in_array($term->vocabulary_machine_name, array_keys($alias->varg))) {
      view_alias_create_alias($term, $alias, 'update');
    }
  }
}

/**
 * Implements hook_taxonomy_term_update().
 */
function view_alias_taxonomy_term_update($term) {
  view_alias_taxonomy_term_delete($term);
  view_alias_taxonomy_term_insert($term);
}

/**
 * Implements hook_taxonomy_term_delete().
 */
function view_alias_taxonomy_term_delete($term) {
  $aliasable = _get_aliasable_displays();
  foreach ($aliasable as $alias) {
    if (in_array($term->vocabulary_machine_name, array_keys($alias->varg))) {
      view_alias_delete_alias($term, $alias);
    }
  }
}

/**
 * Given a term, generate its view aliases.
 */
function view_alias_create_alias($term, $alias, $op) {
  module_load_include('inc', 'pathauto');

  // switch around the pattern based on if the term id is contained within the new alias
  if (strpos($alias->path, '%') === FALSE) {
    $source = $alias->path . '/' . $term->tid;
  }
  else {
    $source = str_replace('%', $term->tid, $alias->path);
  }
  $data = array('term' => $term);
  $alias_path = array( 0 => pathauto_create_alias('view_alias', $op, $source, $data, $alias->bundle, LANGUAGE_NONE));
  return $alias_path;
}

/**
 * Delete an alias set by View Alias.
 */
function view_alias_delete_alias($term, $alias) {
  $alias_path = view_alias_create_alias($term, $alias, 'return');
  /**IDYNAMIC PATCHED*/
  foreach ($alias_path as $alias) {
    path_delete(array('alias' => $alias));
  }
}

/**
 *
 * find the views that can be aliased.
 * that means have a path url and use a term id as an argument
 * build and array of objects, keyed with the view name, having the view path, and the vocabulary id for the terms used
 * array(
 *   0 =>
 *     object (
 *       'view_name' -> 'viewname'
 *       'display_name' -> 'display name'
 *       'path' -> 'view url path'
 *       'vid' -> 'vocabulary id'
 *     )
 * )
 */
function _get_aliasable_displays() {
  $aliasable_views = array();

  $views = views_get_all_views();
  foreach ($views as $view) {
    if (!empty($view->disabled)) {
      continue;
    }
    if (empty($view->display)) {
      continue;
    }

    $alias = new stdClass;
    $alias->view_name = $view->name;

    foreach($view->display as $key => $display) {
      // check default for args and save for later
      if($key == 'default') {
        $default_varg = _find_view_arguments($display);
        continue;
      }

      // Skip displays with no path
      if (empty($display->display_options['path'])) {
        continue;
      }

      // Add the display name, path and replace overridden args.
      $alias->display_name = $key;
      $alias->bundle = $alias->view_name . '-' . $alias->display_name;

      $alias->path = $display->display_options['path'];
      if (isset($display->display_options['defaults']['arguments']) &&
        ($display->display_options['defaults']['arguments'] === FALSE)) {
        $alias->varg = _find_view_arguments($display);
      }
      else {
        // Restore default varg -- previous displays may have been overridden
        $alias->varg = $default_varg;
      }

      if(!empty($alias->path) && !empty($alias->varg)) {
        $aliasable_views[] = clone($alias);
      }
    }
  }

  return $aliasable_views;
}

/**
 * helper to dig out the view arguments.
 */
function _find_view_arguments($display) {
  // No arguments?  Return FALSE.
  if (empty($display->display_options['arguments'])) {
    return FALSE;
  }

  // Scan the display for the first term arg.
  // (No multiple argument support, yet)
  $view_args = array();
  foreach ($display->display_options['arguments'] as $arg_name => $argument) {
    // If we don't support all arguments, we can't create an alias.
    if (($argument['validate_type'] != 'taxonomy_term') ||
        (empty($argument['validate_options']))) {
      return FALSE;
    }
    $view_args = array_filter($argument['validate_options']['vocabularies']);
  }
  return ($view_args) ? $view_args : FALSE;
}
