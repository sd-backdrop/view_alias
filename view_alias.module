<?php
/**
 * @file
 * Hook implementations for view alias module integration.
 *
 * @ingroup pathauto
 */

/**
 * Implements hook_pathauto().
 */
function view_alias_pathauto($op) {
  switch ($op) {
    case 'settings':

      $settings = array();
      $settings['module'] = 'view_alias';
      $settings['token_type'] = 'term'; //view_alias

      $settings['groupheader'] = t('View Alias Paths');
      $settings['patterndescr'] = t('Default View Alias pattern (applies to all views with a term argument and page display)');
      $settings['patterndefault'] = ''; // Not used

      $settings['batch_update_callback'] = 'view_alias_bulk_update_batch_process';

      return (object) $settings;
      break;
  }
}


function view_alias_siple_path($path) {
  return str_replace(array('%/', '%'), '', $path);
}
//function view_alias_create_multiple($vid,$alias,$op) {
/**
 * Batch processing callback; Generate aliases for taxonomy terms.
 */
function view_alias_bulk_update_batch_process(&$context) {
  $aliasable = _get_aliasable_displays();
  foreach ($aliasable as $alias) {
    if (variable_get('pathauto_view_alias_' . view_alias_siple_path($alias->path), FALSE)) {
      $terms = taxonomy_get_tree(view_alias_first_vid($alias->vid));
      foreach ($terms as $term) {
        view_alias_create_alias($term, $alias, 'bulkupdate');
      }
    }
  }
}

/**
 * Implements hook_path_alias_types().
 * allows me to hook into the bulk delete
 */
function view_alias_path_alias_types() {
  $aliasable = _get_aliasable_displays();
  foreach ($aliasable as $alias) {
    $objects[view_alias_siple_path($alias->path)] = t("View page displays having a path of '" . $alias->path . "'");
  }

  return $objects;
}

function view_alias_first_vid($vids) {
  foreach ($vids as $id => $vid) {
    return $id;
  }
  return FALSE;
}

function view_alias_vids_tail($vids) {
  $newvids = array();
  $first = TRUE;
  foreach ($vids as $key => $val) {
    if ($first) {
      $first = FALSE;
      continue; //skip the first
    }
    $newvids[$key] = $val;
  }
  return $newvids;
}
/**
 * Implements hook_form_alter().
 * remove the default form settings and add our own since view alias are different from the regular aliases
 */
function view_alias_form_alter(&$form, &$form_state, $form_id) {

  if ($form_id == 'pathauto_patterns_form') {
    unset($form['view_alias']['token_help']);
    unset($form['view_alias']['pathauto_view_alias_pattern']);

    $form['view_alias']['views_to_alias'] = array(
      '#type' => 'fieldset',
      '#title' => 'Views available for aliasing',
      '#description' => 'Check the views for which aliases should be bulk generated.',
      '#weight' => -1,
    );

    $aliasable = _get_aliasable_displays();
    foreach ($aliasable as $alias) {
      $voc = taxonomy_vocabulary_load(view_alias_first_vid($alias->vid));
      $form['view_alias']['views_to_alias']['pathauto_view_alias_' . view_alias_siple_path($alias->path)] = array(
        '#type' => 'checkbox',
        '#title' => t('View <strong> @view_name' . '</strong>, display <strong> @display_name' . '</strong>, on path <strong>@path' . '</strong>, with <strong>@name' . '</strong> arguments.', array('@view_name' => $alias->view_name, '@display_name' => $alias->display_name, '@path' => $alias->path, '@name' => $voc->name)),
        '#weight' => -1,
        '#default_value' => variable_get("pathauto_view_alias_" . view_alias_siple_path($alias->path), 0),
      );
    }
  }
}

/**
 * Implements hook_taxonomy_term_insert().
 */
function view_alias_taxonomy_term_insert($term) {
  $aliasable = _get_aliasable_displays();
  foreach ($aliasable as $alias) {
    if (in_array($term->vid, array_keys($alias->vid))) {
      view_alias_create_alias($term, $alias, 'update');
    }
  }
}

/**
 * Implements hook_taxonomy_term_update().
 */
function view_alias_taxonomy_term_update($term) {
  view_alias_taxonomy_term_delete($term);
  view_alias_taxonomy_term_insert($term);
}

/**
 * Implements hook_taxonomy_term_delete().
 */
function view_alias_taxonomy_term_delete($term) {
  $aliasable = _get_aliasable_displays();
  foreach ($aliasable as $alias) {
    if (in_array($term->vid, array_keys($alias->vid))) {
      view_alias_delete_alias($term, $alias);
    }
  }
}

function view_alias_generate_multiple($vids, $term, $op, $pattern, $data, &$alias_path) {
    if (count($vids) == 0) { //Generate aliases as we are in the end level of all args.
      $langs = array_keys(language_list());
      $langs[] = LANGUAGE_NONE;

      $source = str_replace(array_keys($data['ids']), array_values($data['ids']), $pattern);

      foreach ($langs as $lang) {
        $parts = explode('/', $pattern);
        $viewpath = $parts[0];
        $parts[0] = t($parts[0], array(), array('context' => 'view_alias', 'langcode' => $lang)); //translate the first part of the view
        $translatedPattern = implode('/', $parts);

        variable_set('pathauto_view_alias_pattern', $translatedPattern);

        $translatedData = array();;
        foreach ($data['data'] as $key => $title) {
          if (intval($data['ids'][$key]) == 0) { //All exception.
            $translatedData[$key] = t($title, array(), array('context' => 'view_alias', 'langcode' => $lang)); //translate the first part of the view
          }
          else{
            $translatedData[$key] = i18n_string("taxonomy:term:{$data['ids'][$key]}:name", $title, array('langcode' => $lang));
          }
        }

        $ap = pathauto_create_alias('view_alias',
                                            $op,
                                            $source,
                                            $translatedData,
                                            'view_alias_' . $viewpath,
                                            $lang);
         if ($ap) {
           $alias_path[] = $ap;
         }
      }
    }
    else {
      $vid = view_alias_first_vid($vids);

      if (isset($vids[$vid]['exception']['value'])) {
        $all = new stdClass();
        $all->tid = $vids[$vid]['exception']['value'];
        $all->vid = $vid;
        $all->name = $vids[$vid]['exception']['value'];
      }
      if ($vid != $term->vid) {
        $terms = taxonomy_get_tree($vid);
        if (isset($all)) {
          $terms = array_merge_recursive(array(0 => $all), $terms);
        }
      }
      else {
        $terms = array($term->tid => $term);
        if ($op == 'bulkupdate' && isset($all)) {
          $terms = array_merge_recursive(array(0 => $all), $terms); //Generete terms also for all.
        }
      }

      foreach ($terms as $t) {
        $data['ids']['[view_alias:name' . $vid . ']']   = $t->tid;
        $data['data']['[view_alias:name' . $vid . ']']  = $t->name;
        view_alias_generate_multiple(view_alias_vids_tail($vids), $term, $op, $pattern, $data, $alias_path);
      }
    }
    return $alias_path;
}

function view_alias_tokens($type, $tokens, $data = array(), $options = array()) {
    $replacements = array();
    $sanitize = !empty($options['sanitize']);

    if (substr($type, 0, 10) == 'view_alias') {
      return $data;
    }

    return $replacements;
}

/**
 * Given a term, generate its view aliases.
 */
function view_alias_create_alias($term, $alias, $op) {
  module_load_include('inc', 'pathauto');

  // switch around the pattern based on if the term id is contained within the new alias
  if (strpos($alias->path, '%') === FALSE) {
    $source = $alias->path . '/' . $term->tid;
    variable_set('pathauto_view_alias_pattern', $alias->path . '/[term:name]');
    $data = array('term' => $term);
    $alias_path = array( 0 => pathauto_create_alias('view_alias', $op, $source, $data, NULL, LANGUAGE_NONE));
    return $alias_path;
  }
  else {
    /**IDYNAMIC PATCHED for multiple terms*/
    $pattern = $alias->path;
    foreach ($alias->vid as $vid => $vargs) {
      $pattern = preg_replace('/\%/', '[view_alias:name' . $vid . ']', $pattern, 1);
    }
    if ($pattern == '') {
      exit('empty pattern');
    }
    $data = $alias_path = array();
    view_alias_generate_multiple($alias->vid, $term, $op, $pattern, $data, $alias_path);

//    $source = str_replace('%', $term->tid, $alias->path);
    /*
      TODO Be more accurate with which url param gets swapped out for the term argument based on index on the view
    */
//    variable_set('pathauto_view_alias_pattern', str_replace('%', '[term:name]', $alias->path));
//    $data = array('term' => $term);
//    $alias_path = pathauto_create_alias('view_alias', $op, $source, $data, NULL, LANGUAGE_NONE);
  }
  return $alias_path;
}

/**
 * Delete an alias set by View Alias.
 */
function view_alias_delete_alias($term, $alias) {
  $alias_path = view_alias_create_alias($term, $alias, 'return');
  /**IDYNAMIC PATCHED*/
  foreach ($alias_path as $alias) {
    path_delete(array('alias' => $alias));
  }
}

/**
 *
 * find the views that can be aliased.
 * that means have a path url and use a term id as an argument
 * build and array of objects, keyed with the view name, having the view path, and the vocabulary id for the terms used
 * array(
 *   0 =>
 *     object (
 *       'view_name' -> 'viewname'
 *       'display_name' -> 'display name'
 *       'path' -> 'view url path'
 *       'vid' -> 'vocabulary id'
 *     )
 * )
 */
function _get_aliasable_displays() {
  $aliasable_views = array();
  $all_views = views_get_all_views();

  foreach($all_views as $aview){

    $alias = new stdClass;
    $alias->view_name = $aview->name;
    $default_vocab_arg;

    foreach ($aview->display as $key => $display) {

      $alias->display_name = $key;

      // check default for args and save for later
      if ($key == 'default') {
        $alias->vid = _find_view_arguments($display);
        continue;
      }
      // its some sort of page cause the query says so.
      else {

        // Skip of display doesn't have a path
        if (empty($display->display_options['path'])) {
          continue;
        }

        // add the page and replace overridden args.
        $alias->path = $display->display_options['path'];
        $overridden = _find_view_arguments($display);
        if ($overridden) {
          $alias->vid = $overridden;
        }
      }
      if (!empty($alias->path) && !empty($alias->vid)) {
        $aliasable_views[$alias->path] = clone($alias);
      }
    }
  }

  return $aliasable_views;
}

/**
 * helper to dig out the view arguments.
 */
function _find_view_arguments($display) {

  if (empty($display->display_options['arguments']))
    return FALSE;
  $view_args = $display->display_options['arguments'];

  $vids = array();
  foreach ($view_args as $view_arg) {
    if (isset($view_arg['validate']['type']) && $view_arg['validate']['type'] == 'taxonomy_term') {
      if (!empty($view_arg['validate_options']['vocabularies']) && is_array($view_arg['validate_options']['vocabularies'])) {
        foreach ($view_arg['validate_options']['vocabularies'] as $vocab_name) {
          $vocab = taxonomy_vocabulary_machine_name_load($vocab_name);
          $vids[$vocab->vid] = $view_arg;
        }
      }
    }
  }
  return $vids;
}
